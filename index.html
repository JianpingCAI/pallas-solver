<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Pallas Solver: Pallas Solver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Pallas Solver
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">C++ Global Optimization Algorithms</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Pallas Solver </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This project is a suite of global optimization algorithms for C++ inspired by SciPy's global optimization package. Currently supported functions are:</p>
<ul>
<li><a class="el" href="classpallas_1_1_basinhopping.html" title="Minimizes an objective function by sequentially hopping between minima in the objective&#39;s energy land...">pallas::Basinhopping</a></li>
<li><a class="el" href="classpallas_1_1_brute.html" title="Minimizes an objective function by brute force, trying all possible combinations of specified paramet...">pallas::Brute</a></li>
<li><a class="el" href="classpallas_1_1_differential_evolution.html" title="Minimizes an objective function by continuously evolving a population of candidate solutions...">pallas::DifferentialEvolution</a></li>
<li><a class="el" href="classpallas_1_1_simulated_annealing.html" title="Minimizes a function using simulated annealing. ">pallas::SimulatedAnnealing</a></li>
</ul>
<p>For more information on the options for each algorithm please see the documentation at: <a href="http://latture.github.io/pallas-solver">http://latture.github.io/pallas-solver</a></p>
<h2>Dependencies </h2>
<ul>
<li>C++11 compatible compiler.</li>
<li><a href="https://github.com/google/glog">glog</a></li>
<li><a href="http://www.cmake.org/">CMake</a></li>
<li><a href="http://ceres-solver.org/">Ceres</a></li>
</ul>
<h2>Building and Installation </h2>
<p>To use this library first install glog and CMake. Pallas is based off of the Google Ceres project which has extensive use of glog for logging and debugging features, and this functionality is carried over into Pallas. Follow the instructions to install Ceres at <a href="http://ceres-solver.org/building.html">ceres-solver.org/building.html</a>. Once CMake, Ceres, and glog are built and installed use the following steps to build Pallas:</p><ul>
<li>Navigate to the pallas root directory.</li>
<li>On the same level as the <code>README.md</code>, create a folder named <code>build</code>.</li>
<li>In the terminal, navigate to the newly created <code>build</code> folder.</li>
<li>Execute the following command: <code>cmake .. -DCMAKE_PREFIX_PATH=/path/to/CeresConfig.cmake</code>, where <code>/path/to/CeresConfig.cmake</code> denotes the folder where the file <code>CeresConfig.cmake</code> is located Currently on Linux, Ceres by default will place this file at <code>/usr/local/share/Ceres</code>, though this may change in the future and may be different on your machine.</li>
<li>From within the same build directory execute <code>make</code> in the terminal. This should build Pallas. The folder <code>build/lib</code> will hold the library</li>
</ul>
<h2>Example </h2>
<p>The <a class="el" href="class_rosenbrock.html">Rosenbrock</a> function (shown below) is a commonly used benchmarking function for optimization algorithms. The global minimum is in the middle of a narrow valley at <code>f(x, y) = 0</code> when <code>x = y = 1</code>. Finding the valley is fairly easy; however, finding the global minimum is quite a bit harder...</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;glog/logging.h&quot;</span></div><div class="line"></div><div class="line"><span class="comment">// Each solver is defined in its own header file.</span></div><div class="line"><span class="comment">// include the solver you wish you use:</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="basinhopping_8h.html">pallas/basinhopping.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="comment">// define a problem you wish to solve by inheriting</span></div><div class="line"><span class="comment">// from the pallas::GradientCostFunction interface</span></div><div class="line"><span class="comment">// and implementing the Evaluate and NumParameters methods.</span></div><div class="line"><span class="keyword">class </span><a class="code" href="class_rosenbrock.html">Rosenbrock</a> : <span class="keyword">public</span> pallas::GradientCostFunction {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> ~<a class="code" href="class_rosenbrock.html">Rosenbrock</a>() {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> Evaluate(<span class="keyword">const</span> <span class="keywordtype">double</span>* parameters,</div><div class="line">                          <span class="keywordtype">double</span>* cost,</div><div class="line">                          <span class="keywordtype">double</span>* gradient)<span class="keyword"> const </span>{</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> x = parameters[0];</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> y = parameters[1];</div><div class="line"></div><div class="line">        cost[0] = (1.0 - x) * (1.0 - x) + 100.0 * (y - x * x) * (y - x * x);</div><div class="line">        <span class="keywordflow">if</span> (gradient != NULL) {</div><div class="line">            gradient[0] = -2.0 * (1.0 - x) - 200.0 * (y - x * x) * 2.0 * x;</div><div class="line">            gradient[1] = 200.0 * (y - x * x);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> NumParameters()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 2; }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div><div class="line">    google::InitGoogleLogging(argv[0]);</div><div class="line"></div><div class="line">    <span class="comment">// define the starting point for the optimization</span></div><div class="line">    <span class="keywordtype">double</span> parameters[2] = {-1.2, 0.0};</div><div class="line"></div><div class="line">    <span class="comment">// set up global optimizer options only initialization</span></div><div class="line">    <span class="comment">// is need to accept the default options</span></div><div class="line">    <a class="code" href="structpallas_1_1_basinhopping_1_1_options.html">pallas::Basinhopping::Options</a> options;</div><div class="line"></div><div class="line">    <span class="comment">// initialize a summary object to hold the</span></div><div class="line">    <span class="comment">// optimization details</span></div><div class="line">    <a class="code" href="structpallas_1_1_basinhopping_1_1_summary.html">pallas::Basinhopping::Summary</a> summary;</div><div class="line"></div><div class="line">    <span class="comment">// create a problem from your cost function</span></div><div class="line">    pallas::GradientProblem problem(<span class="keyword">new</span> <a class="code" href="class_rosenbrock.html">Rosenbrock</a>());</div><div class="line"></div><div class="line">    <span class="comment">// solve the problem and store the optimal position</span></div><div class="line">    <span class="comment">// in parameters and the optimization details in</span></div><div class="line">    <span class="comment">// the summary</span></div><div class="line">    pallas::Solve(options, problem, parameters, &amp;summary);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; summary.<a class="code" href="structpallas_1_1_basinhopping_1_1_summary.html#a35b1f1d1bac489d8ffbede48e11198b8">FullReport</a>() &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Global minimum found at:&quot;</span> &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;\tx: &quot;</span> &lt;&lt; parameters[0] &lt;&lt; <span class="stringliteral">&quot;\ty: &quot;</span> &lt;&lt; parameters[1] &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">    }</div></div><!-- fragment --><p>After compiling and running, the console should display the following:</p>
<div class="fragment"><div class="line">Solver Summary</div><div class="line"></div><div class="line">Parameters                                  2</div><div class="line">Line search direction                   LBFGS</div><div class="line"></div><div class="line">Cost:</div><div class="line">  Initial                        2.122000e+02</div><div class="line">  Final                          3.300841e-27</div><div class="line">  Change                         2.122000e+02</div><div class="line"></div><div class="line">Minimizer iterations                       21</div><div class="line"></div><div class="line">Time (in seconds):</div><div class="line">  Cost evaluation                      0.0000</div><div class="line">  Local minimization                   0.0015</div><div class="line">  Step function                        0.0000</div><div class="line">  Total                                0.0015</div><div class="line"></div><div class="line">Termination: CONVERGENCE (Maximum number of stagnant iterations reached.)</div><div class="line"></div><div class="line">Global minimum found at:</div><div class="line">    x: 1    y: 1</div></div><!-- fragment --><p>This example (among others) can be found in the examples folder.</p>
<h2>Getting started </h2>
<p>Pallas global optimization algorithms take as inputs an <code>Options</code> struct class specific to each optimizer, <code>GradientProblem</code> which encapsulates the objective function to optimize, a <code>const double*</code> pointing to the initial starting point for optimization (except for Brute which takes a range of parameters), and a summary in which details of the optimization are stored. The <code>Options</code> struct is a subclass specific to each optimizer exposing the options that can be changed in order to customize the optimization procedure. If Basinhopping is being used as the global optimizer, creating an instance of the default options is as simple as:</p>
<div class="fragment"><div class="line"><a class="code" href="structpallas_1_1_basinhopping_1_1_options.html">pallas::Basinhopping::Options</a> options;</div></div><!-- fragment --><p>The default options can be changed by accessing member variables:</p>
<div class="fragment"><div class="line">options.maxiterations = 1000;</div></div><!-- fragment --><p>If the global optimizer employs a local minimizer, the options for the local minimizer are accessed through the <code>options.local_minimizer_options</code> minimizer variable. <code>options.local_minimizer_options</code> is itself a struct containing the parameters to augment the functionality of the local minimization step(s). The local minimization options are from the <code>ceres::GradientProblemSolver</code> renamed to <code>pallas::GradientLocalMinimizer</code> to avoid confusion between the global and local solvers. If <code>DifferentialEvolution</code> is being used as the global optimizer, the <code>options</code> struct requires that upper and lower bounds be set for the current problem. Note, however, that if the final output is polished (<code>options.polish = true</code>) the local optimization will not respect the bounds of the global optimization due to the restriction of the Ceres local optimization algorithms to purely unbounded problems. Both the <code>SimulatedAnnealing</code> and <code>Basinhopping</code> algorithms use the <code>StepFunction</code> class to generate randomized candidate solutions. A <a class="el" href="classpallas_1_1scoped__ptr.html">pallas::scoped_ptr</a> to a <code>DefaultStepFunction</code> is created by default. This is not going to give optimal results for your problem. If either of these algorithms are being used a class should inherit from <code>StepFunction</code> and implement the <code>Step</code> method which takes as inputs a pointer to the current solution and the number of parameters, then modifies the current solution in place. If a <code>StepFunction</code> is used by the global optimizer, then the options struct has a helper method <code>set_step_function</code> that swaps the pointer to the default step function with the user defined functor. The following shows how to create a step functor and replace it as the step function pointer in the options struct:</p>
<div class="fragment"><div class="line"><span class="comment">// inherit from StepFunction and implement Step method</span></div><div class="line"><span class="keyword">class </span>CustomStepFunction : <span class="keyword">public</span> <a class="code" href="classpallas_1_1_step_function.html">pallas::StepFunction</a> {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    CustomStepFunction(<span class="keywordtype">double</span> step_size)</div><div class="line">        : random_number_(new <a class="code" href="namespacepallas.html">pallas</a>::internal::RandomNumberGenerator&lt;double&gt;(-step_size, step_size)) {</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="classpallas_1_1_step_function.html#a46d29672a4b8adacf2a903b0c0b92831">Step</a>(doublex, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> num_parameters) {</div><div class="line">        <span class="comment">// implementation to modify x in place</span></div><div class="line">    };</div><div class="line"></div><div class="line">     <span class="keyword">private</span>:</div><div class="line">         <a class="code" href="classpallas_1_1scoped__ptr.html">pallas::scoped_ptr&lt;pallas::internal::RandomNumberGenerator&lt;double&gt;</a>&gt; random_number_;</div><div class="line">     };</div><div class="line"></div><div class="line"><span class="comment">// create the options for the solver</span></div><div class="line"><a class="code" href="structpallas_1_1_basinhopping_1_1_options.html">pallas::Basinhopping::Options</a> options;</div><div class="line"></div><div class="line"><span class="comment">// instantiate scoped pointer to StepFunction</span></div><div class="line"><a class="code" href="classpallas_1_1scoped__ptr.html">pallas::scoped_ptr&lt; CustomStepFunction &gt;</a> step(<span class="keyword">new</span> CustomStepFunction(1.0));</div><div class="line"></div><div class="line"><span class="comment">// use convenience method to replace default step function</span></div><div class="line">options.<a class="code" href="structpallas_1_1_basinhopping_1_1_options.html#aeac52011e9ed2c9a0e9e7a035e744fda">set_step_function</a>(step);</div></div><!-- fragment --><p>Subclassing <code>pallas::GradientCostFunction</code> and implementing the <code>Evaluate</code> and <code>NumParameters</code> methods defines your objective function. Create a <code>GradientProblem</code> using:</p>
<div class="fragment"><div class="line">pallas::GradientProblem problem(<span class="keyword">new</span> YourObjectiveFuntion());</div></div><!-- fragment --><p>The gradient problem is what is then passed to the solver. The <code>parameters</code> for the global optimization represents an initial guess required for the <code>Basinhopping</code> and <code>SimulatedAnnealing</code> algorithms. It should be a <code>double*</code> and contain the same number of values as the <code>NumParameters</code> method returns. Each global optimizer contains a <code>Summary</code> class used to store the results of the global optimization. The summary is created in the same manner as the options struct, i.e.:</p>
<div class="fragment"><div class="line"><a class="code" href="structpallas_1_1_basinhopping_1_1_summary.html">pallas::Basinhopping::Summary</a> summary;</div></div><!-- fragment --><p>This is then passed as the final parameter to the solver. There are 2 methods optimize a cost function. An instance of the solver can be created then optimized using the <code>global_optimizer.Solve</code> method. There is also a <code>pallas::Solve</code> function added for convenience. It is overloaded to create a global optimizer instance and run the optimization based on the parameters passed to the function. To summarize, the two method of optimization are given by:</p>
<div class="fragment"><div class="line"><span class="comment">// create an instance of a global optimizer</span></div><div class="line"><a class="code" href="classpallas_1_1_basinhopping.html">pallas::Basinhopping</a> bh;</div><div class="line">bh.<a class="code" href="classpallas_1_1_basinhopping.html#ad896094bfbc1e17c259bc6d870325c1e">Solve</a>(options, problem, parameters, &amp;summary);</div><div class="line"></div><div class="line"><span class="comment">// bypass the creation of the optimizer</span></div><div class="line">pallas::Solve(options, problem, parameters, &amp;summary)</div></div><!-- fragment --><h2>Contributor(s) </h2>
<ul>
<li>Ryan Latture</li>
</ul>
<h2>Credits </h2>
<p>This library uses the local minimization algorithms from Google's Ceres solver. Implementations of the global optimization algorithms are based on Scipy's optimize package. Because of the similarities between the Pallas algorithms and scipy.optimize, much of the documentation was adapted from their source. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue May 3 2016 00:26:05 for Pallas Solver by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
